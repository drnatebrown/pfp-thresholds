#!/usr/bin/env python3

# Edited from bigbwt script file

import sys, time, argparse, subprocess, os.path, threading

Description = """
Tool to build the BWT and the Thresholds for higly repetive files using the approach
described in

   "Constructing thresholds directly from prefix-free parsing"
   by Christina Boucher, Travis Gagie, and Massimiliano Rossi

The input file cannot contain the characters 0, 1 or 2 which are
used internally by the algorithm.
"""

version = "@PFP_THRESHOLDS_VERSION@"
install = @USE_INSTALL_PATH@


dirname         = os.path.dirname(os.path.abspath(__file__))

tools_dirname   = dirname

if not install:
  tools_dirname   = os.path.join(dirname, "test/src")

pfp  = "@PFP_EXE@"
pfp_thresholds  = os.path.join(tools_dirname, "pfp_thresholds")
pfp_lcp  = os.path.join(tools_dirname, "pfp_lcp")
# pfp_thresholds64  = os.path.join(tools_dirname, "pfp_thresholds64")
# pfp_lcp64  = os.path.join(tools_dirname, "pfp_lcp64")


class PFPthresholds(threading.Thread):
  def __init__(self, name, counter, args):
    threading.Thread.__init__(self)
    self.threadID = counter
    self.name = name
    self.counter = counter
    self.args = args

  def run(self):
    args = self.args
    logfile = args.logfile
    logfile_name = args.logfile_name
    print("{} PFP Thresholds started!".format(self.getName()))        # "Thread-x started!"

    start = time.time()
    parse_size = os.path.getsize(args.out_prefix+".parse")/4
    dictionary_size = os.path.getsize(args.out_prefix+".dict")

    exe = pfp_thresholds
    if args.L:
      exe = pfp_lcp
    
    if(parse_size >=  (2**31-1) or dictionary_size >=  (2**31-4) ):
      exe += "64" 

    command = "{exe} {file} -w {wsize}".format(
        exe = exe,
        wsize=args.wsize, file=args.out_prefix)
    if args.stats: command += " -m"
    
    print("==== Computing Thresholds. Command:", command)
    if(execute_command(command,logfile,logfile_name)!=True):
      return
    print("Thresholds Elapsed time: {0:.4f}".format(time.time()-start));

class PFP(threading.Thread):
  def __init__(self, name, counter, args):
    threading.Thread.__init__(self)
    self.threadID = counter
    self.name = name
    self.counter = counter
    self.args = args

  def run(self):
    args = self.args
    logfile = args.logfile
    logfile_name = args.logfile_name
    print("{} PFP started!".format(self.getName()))        # "Thread-x started!"

    start = time.time()

    command = "{exe} -w {wsize} -p {pval} -j {jobs} -o {out} --tmp-dir {tmp} ".format(
        exe     = pfp,
        wsize   = args.wsize,
        pval    = args.mod,
        jobs    = args.threads,
        out     = args.out_prefix,
        tmp     = args.tmp_dir)

    if args.compress: command += "-c "
    if args.lidx: command += "-i "
    if args.lvsm: command += "-l "
    if args.verbose: command += "--verbose "
    if args.stats: command += "--print-statistics "

    if args.reference is not None: 
      command += "-r {ref} -v {vcf} -H {H} --use-acceleration ".format(
        ref = args.reference.replace(',',' '),
        vcf = args.vcf.replace(',',' '),
        H   = args.haplotype 
      )
      if args.n_samples is not None: 
        command += "-m {} ".format(args.n_samples)
      elif args.samples is not None:
        command += "-S {} ".format(args.samples)
    elif args.fasta is not None: # TODO: Change this when pfp will suport different formats
      command += "-f {} ".format(args.fasta)
    elif args.text is not None: # TODO: Change this when pfp will suport different formats
      command += "-t {} ".format(args.text)

    print("==== Computing PFP. Command:", command)
    if(execute_command(command,logfile,logfile_name)!=True):
      return
    print("PFP Elapsed time: {0:.4f}".format(time.time()-start));



def getGitDesc():
  branch = subprocess.check_output(
      'git rev-parse --abbrev-ref HEAD', shell=True, cwd=dirname).strip().decode("utf-8")
  commit = subprocess.check_output(
      'git rev-parse HEAD', shell=True, cwd=dirname).strip().decode("utf-8")
  try:
    tag = subprocess.check_output('git describe --exact-match {commit_id}'.format(commit_id=commit),
                                  shell=True, cwd=dirname).strip().decode("utf-8")
  except subprocess.CalledProcessError as e:
    tag = ""
  return "branch: {branch}\n   tag: {tag}\ncommit: {commit}".format(branch=branch, tag=tag, commit=commit)


def base(args):
  if args.version:
    print(getGitDesc())

def getVersion():
  if not version:
    return getGitDesc()
  else:
    return version

def main():
  parser = argparse.ArgumentParser( description=Description, formatter_class=argparse.RawTextHelpFormatter)
  
  vcf_group = parser.add_argument_group('VCF', 'Arguments for VCF files')
  vcf_group.add_argument('-r', '--reference',   help='coma-separated list of reference files, e.g., ref1[,ref2,ref3].', type = str)
  vcf_group.add_argument('-v', '--vcf',         help='coma-separated list of VCF files, e.g., vcf1[,vcf2,vcf3].', type = str)
  vcf_group.add_argument('-H', '--haplotype',   help='Haplotype to generate. [1,2,12].', default="1", type = str)
  mutual_exclusive = vcf_group.add_mutually_exclusive_group()
  mutual_exclusive.add_argument('-n', '--n-samples',   help='number of samples in the VCF file to analyze.', type = int)
  mutual_exclusive.add_argument('-S', '--Samples',     help='file containing the list of samples to parse.', type = str)
  fasta_group = parser.add_argument_group('FASTA', 'Arguments for FASTA files')
  fasta_group.add_argument('-f', '--fasta',     help='coma-separated list of FASTA files, e.g., fa1[,fa2,fa3].', type = str)
  text_group = parser.add_argument_group('TXT', 'Arguments for TEXT files')
  text_group.add_argument('-t', '--text',       help='coma-separated list of TEXT files, e.g., txt1[,txt2,txt3].', type = str)
  pfp_group = parser.add_argument_group('PFP', 'Arguments for PFP generation')
  pfp_group.add_argument('-w', '--wsize',       help='sliding window size (def. 10)', default=10, type=int)
  pfp_group.add_argument('-p', '--mod',         help='hash modulus (def. 100)', default=100, type=int)
  pfp_group.add_argument('-c', '--compress',    help='compress output of the parsing phase (debug only)',action='store_true')
  parser.add_argument('-j', '--threads',        help='number of helper threads (def. None)', default=0, type=int)
  parser.add_argument('-o', '--out-prefix',     help='Output prefix.', default="out", type=str)
  parser.add_argument('-i', '--lidx',           help='Output contig lengths list in lidx format.', action='store_true')
  parser.add_argument('-I', '--lvsm',           help='Output lifting file in lvsm format.', action='store_true')
  parser.add_argument('--log-file',             help="Log filename prefix.", default = "out", type = str)
  parser.add_argument('--tmp-dir',              help="Tmp file directory.", default = ".", type = str)
  parser.add_argument('-s', help='compute the start run-length sampled Suffix Array',action='store_true')
  parser.add_argument('-e', help='compute the end run-length sampled Suffix Array',action='store_true')
  parser.add_argument('-l', help='compute the start run-length sampled LCP Array (to be implemented).',action='store_true')
  parser.add_argument('-A', help='compute the Suffix Array (to be implemented).',action='store_true')
  parser.add_argument('-L', help='compute the LCP Array',action='store_true')
  parser.add_argument('-k', help='keep temporary files',action='store_true')
  parser.add_argument('--verbose', help='verbose',action='store_true')
  parser.add_argument('--stats', help='print statistics.',action='store_true')
  parser.add_argument('--version',  action='version', version='%(prog)s\n{}'.format(getVersion()))
  parser.set_defaults(which='base')
  args = parser.parse_args()

  if args.fasta is not None and args.threads > 0 and (".fq" in args.fasta or ".fastq" in args.fasta or ".fnq" in args.fasta):
    print("thresholds does not current support FASTQ format! Exiting...")
    return

  # Check that at least one among -r -f -t is selected
  if args.reference is None and args.fasta is None and args.text is None:
    print("bigbwt does not current support FASTQ format! Exiting...")

  # Generate logfile name
  logfile_name = args.out_prefix
  if args.log_file is not None:
    logfile_name = args.log_file

  logfile_name += ".thr.log"
  
  # get main bigbwt directory
  print("Sending logging messages to file:", logfile_name)
  with open(logfile_name,"a") as logfile:
    args.logfile = logfile
    args.logfile_name = logfile_name
    start = time.time()
    # ---------- parsing of the input file
    pfp_thread = PFP(name = "{}".format(args.out_prefix), args=args, counter=1)  # ...Instantiate a thread and pass a unique ID to it
    pfp_thread.start()                                      # ...Start the thread, invoke the run method
    pfp_thread.join()                                       # ...Start the thread, invoke the run method

    # ----------- computation of the PFP data structures    
    pfpthresholds_thread = PFPthresholds(name = "{}".format(args.out_prefix), args=args, counter=1)  # ...Instantiate a thread and pass a unique ID to it
    pfpthresholds_thread.start()                                       # ...Start the thread, invoke the run method
    pfpthresholds_thread.join()

    print("Total construction time: {0:.4f}".format(time.time()-start))
    # ---- print elapsed time to file
    command = "echo Total construction time: {0:.4f}".format(time.time()-start)
    if(execute_command(command,logfile,logfile_name)!=True):
      return

    # ---- delete intermediate files
    delete_temp_files(args,logfile,logfile_name)

  print("==== Done")

# delete intermediate files
def delete_temp_files(args,logfile,logfile_name):
    if args.k==False:
      print("==== Deleting temporary files.") # no need to show the command
      command = "rm -f {file}.last".format(file=args.out_prefix)
      if(execute_command(command,logfile,logfile_name)!=True):
        return
      

# compute hash digest for a file
def file_digest(name,logfile):
    try:
      hash_command = "{exe} {infile}".format(exe=shasum_exe, infile=name)
      hashsum = subprocess.check_output(hash_command.split(),stderr=logfile)
      hashsum = hashsum.decode("utf-8").split()[0]
    except:
      hashsum = "Error!"
    return hashsum

# execute command: return True is everything OK, False otherwise
def execute_command(command,logfile,logfile_name,env=None):
  try:
    #subprocess.run(command.split(),stdout=logfile,stderr=logfile,check=True,env=env)
    subprocess.check_call(command.split(),stdout=logfile,stderr=logfile,env=env)
  except subprocess.CalledProcessError:
    print("Error executing command line:")
    print("\t"+ command)
    print("Check log file: " + logfile_name)
    return False
  return True



if __name__ == '__main__':
    main()
